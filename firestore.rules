/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-specific data is private, and a user can only ever access their own data. This is achieved by tying all access rules to the user's unique authentication ID (UID).
 *
 * Data Structure: The data is organized into a single top-level collection: `/users`. Each document in this collection has an ID that matches the user's UID, creating a direct and efficient path for ownership-based security checks.
 *
 * Key Security Decisions:
 * - User Enumeration is Disallowed: Listing the entire `/users` collection is explicitly forbidden to prevent attackers from discovering the application's user base. Clients must know a user's UID to fetch their profile directly.
 * - Self-Service Profile Management: Users are allowed to create, read, update, and delete their own profile document. All operations are gated by checking that the requestor's UID matches the document ID in the path.
 * - Relational Integrity: The `id` field within a user document is validated on creation to match the user's UID and is enforced as immutable on update. This prevents any potential ownership hijacking within the data itself.
 *
 * Denormalization for Authorization: This ruleset leverages "Path-Based Ownership." The document's ID (`{userId}`) is the sole piece of data required for authorization. This is the most performant security pattern as it requires no extra document reads (`get()` calls) to make an access decision.
 *
 * Structural Segregation: Not applicable in this model, as all user data is treated as uniformly private. There are no public or shared collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to provide clear, reusable logic.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently signed-in user is the owner of the document,
     * based on the document's path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the signed-in user is the owner and the document already exists.
     * CRITICAL: Used for safe updates and deletes to prevent acting on non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates the creation of a new user document.
     * Ensures the creator is the owner and that the internal `id` field matches the UID for relational integrity.
     */
    function canCreateUser(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Validates the update of an existing user document.
     * Ensures the user is the owner and that the critical `id` field is not changed.
     */
    function isUpdatingOwnImmutableUser(userId) {
      return isExistingOwner(userId) && request.resource.data.id == resource.data.id;
    }

    /**
     * @description Manages user profile documents. Ensures users can only access and modify their own document.
     * @path /users/{userId}
     * @allow An authenticated user (e.g., `auth.uid` = 'user_abc') can `(create)` their own document at `/users/user_abc`.
     * @deny An authenticated user ('user_abc') is denied from `(get)`ting another user's document at `/users/user_xyz`.
     * @principle Restricts access to a user's own data tree and enforces immutability of the user ID.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if canCreateUser(userId);
      allow update: if isUpdatingOwnImmutableUser(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}